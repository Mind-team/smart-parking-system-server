# Smart Parking System Server
[**Client API**](https://github.com/Mind-team/smart-parking-system-server/blob/master/CLIENT-API.md)
## Регистрация пользователя
### Описание
Предположим, что пользователь решает зарегистрироваться.
Регистрация будет проходить с помощью номера телефона.
Пользователь должен ввести **уникальный** номер телефона (в будущем пользователю
будет приходить смс с кодом подтверждения), пароль, **уникальный** email (опционально),
**уникальный/уникальные** регистрационный/регистрационные номер/номера (в будущем будет проходить
проверка с помощью ТС или через гос. услуги). Схема пользователя находится
в папке `src/schemas/user.schema.ts`. <br>
Многие запросы требуют подтверждения пользователя. Например, я хочу добавить регистрационный номер. 
Сервер должен проверить, что я добавляю этот номер себе, а не кому-то другому. Например, GET запрос на получение
данных о пользователе по номеру телефона. Такое действие доступно только владельцу аккаунта. Для всего этого есть 
JWT токен (можете почитать), но его использовать мы пока не будем. На данный момент, в каждом 
запросе, для котрого требуется валидация пользователя, будет как минимум 2 поля: номер телефона и пароль. 
В бд находим пользователя по номеру телефона, а потом сравниваем его пароль и тот, что пришел к нам из запроса. 
Если пароли совпадают, значит можно выполнять запрос, если нет, то выкидываем ошибку.
## API Raspberry Pi
| Метод | URL | Описание |
| ------------- | ------------- | ------------- |
| POST | `parking/registerCarEntry` | Регистрация въезда машины на парковку |
## Скрипты
Здесь только те скрипты, которыми нужно пользоваться
- `npm run start:dev` - запуск приложения в режиме разработки (автоматически перезапускается при изменении файла. Также приложение не билдится)
- `npm run start:debug`- запуск приложения в режиме дебага
- `npm run lint` - исправление код стайла (если это возможно)
- `npm run test` - запуск тестов
- `npm run test:watch` - запуск тестов с автообновлениями
- `npm run test:cov` - показывает процент покрытия кода тестами 
- `npm run type:coverage` - количество типов any в вашем коде
## База данных 
### Работа с моделями из бд
Для работы с моделями из бд мы используем интерфейсы, названия которых оканчиваются на Record. 
То есть интерфейс UserRecord - это то как пользователь записан в бд. Каждый класс-модель, предствленный в бд, 
должен реализовывать интерфейс NameRecord. (Например, у нас есть модель User. User должен реализовывать интерфейс 
UserRecord). В моделе User может быть много разной логики, но бд содержит лишь нужную ей информацию. В UserRecord 
содержатся поля, которые нужны бд. Если User реализиует UserRecord, то мы можем быть уверены, что User содержит
все необходимые поля для записи в бд. Но сам User не должен взаимодействовать с записями и логикой бд. Поэтому 
у нас есть интерфейс Recorder<Record>. Классы, реализующие Recorder<Record> умеют форматировать переданный класс 
в нужный для бд формат (formatForBD). Так же именно эти классы реализуют проверку корректности данных. 
Для User создан UserRecorder. </br>
- Name - это просто модель, содержащая информацию и какое-то поведение. Базе данных нужна какая-то часть этих данных
- NameRecord - это то, как модель Name выглядит в бд. Name должен реализовывать NameRecord интерфейс, если хочет
быть способен для записи в бд
- NameRecorder: Recorder<NameRecord> - сущность, которая умеет форматировать поля Name под небходимый формат для бд.
Также эта сущность проверяет корректность данных
  
1. Создать интерфейс UserRecord 
``` ts
export interface UserRecord {
  name: string;
  age: number;
}
```  

2. Создать класс User, который реализует UserRecord
``` ts
export class User implements UserRecord {
  private _name: string;
  private _age: number;
  
  // Инициализируем данные, которые нам необходимы для работы с пользователем
  constructor(name: string, age: number) {
    this._name = name;
    this._age = age;
  }
  
  get name() {
    return this._name;
  }
  
  get age() {
    return this._age;
  }
  
  // У пользователя может быть какое-то поведение 
  private method() {
    // logic
  }
}
```

3. Создать UserRecorder, реализующий Recorder
``` ts
class UserRecorder implements Recorder<UserRecord> {
  public async formatForDB(value: UserRecord): Promise<UserRecord> {
    // какая то логика
    return obj; 
  }
  
  // тут может быть валидирующая логика и много всего другого
}
```  

4. Используем (просто пример того как это все вместе работает)
``` ts
const user = new User("Name", 18);
const recorder = new UserRecorder();
const userRecord = recorder.formatForDB(user);
db.load(userRecord)
```


## Система ответов
### Интерфейсы
- `ServerResponse` - интерфейс для ответов, которые не должны возвращать какую-либо сущность.
То есть сервер просто должен сообщить об успехе или неудаче
- `FilledServerResponse<T>` - интерфейс для ответов, которые должны возвращать какую-либо 
сущность типа T. То есть сервер должен сообщить об успехе или неудаче и вернуть сущность типа T
  
### Классы
На данный момент существует 3 класса, которые реализуют какой-либо интерфейс
- `SuccessfulServerResponse: ServerResponse`
- `FailedServerResponse: ServerResponse`
- `FilledSuccessfulServerResponse<T>: FilledServerResponse<T>`

Если когда-то понадобится возможность возвращать какую-либо сущность при неудачном ответе,
то нужно реализовать `FilledFailedServerResponse<T>: FilledServerResponse<T>` 
  
### Когда использовать
Сервер обязан ответить на каждый запрос, который ему приходит
- Если от сервера требовалось совершить какое-то действие и сервер с этим справился, 
  то нужно вернуть `SuccessfulServerResponse`
- Если от сервера требовалось соверешить какое-то действие, а сервер с этим не справился,
  то нужно вернуть `FailedServerResponse`
- Если от сервера требовалось совершить какое-то действие, а потом вернуть результат
  этого действия и сервер с этим справился, то нужно вернуть `FilledSuccessfulResponse`
- Если от сервера требовалось совершить какое-то действие, а потом вернуть результат 
  этого действия, а сервер с этим не справился, то нужно вернуть `FailedServerResponse`
  
